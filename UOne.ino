#include <GPIO.h>
#define HIGHADDR PORTA // MSB 8 bits of address lines
#define LOWADDR PORTC // LSB 8 bits of address lines
#define DATAIO PORTF // Data lines to bus
GPIO<BOARD::D46> RWEnable; //Can we write?
#define DATADirection DDRF // Are we READING OR WRITING to data?
#define WRITE 0xFF // Easy peazy
#define READ 0x00; // Opposite of Write, Duh.
#define IOSPACE 16 // How many uint8_ts are each IOSpace on Apple II bus?
#define DEVICESPACE 256 // How big is Apple II Device Rom?
#define IORW1 0 // Address in Apple Buss Ram Share for The 2 way comms in Dual Port SRAM
#define IORW2 IORW1+IOSPACE // Trend Continues
#define IORW3 IORW2+IOSPACE // Need I explain more?
#define DEVICE1 IORW3+IOSPACE // Same Crap
#define DEVICE2 DEVICE1+DEVICESPACE // More of this crap
#define DEVICE3 DEVICE2+DEVICESPACE // You guessed it, least of this crap.
GPIO<BOARD::D21> CARD1PIN;   //GAL PIN 14 INT0
GPIO<BOARD::D20> CARD2PIN;  //GAL PIN 15 INT1
GPIO<BOARD::D19> CARD3PIN;  //GAL PIN 16 INT2
GPIO<BOARD::D42> ENABLEIO;  //TURN ON GAL OUTPUTS AND TRIGGERS
#define CARDCTL PORTJ
#define CARDSELECT1 //GAL INPUT FOR Slot Select 0 PIN 18 + RW == LOW
#define CARDSELECT2 //GAL INPUT FOR Slot Select 1 PIN 19 + RW == LOW
#define CARDSELECT3 //GAL INPUT FOR Slot Select 2 PIN 20 + RW == LOW
#define CMD_NONE       0xFF
#define CMD_STAT       0x00
#define CMD_READ       0x01
#define CMD_WRITE      0x02
#define ERR_WAIT       0x00
#define ERR_IO       0x27
#define ERR_NDEV       0x28
#define ERR_WP       0x2B
#define ERR_READY      0x80
#define HDD_BLOCK_SIZE      512
uint8_t IOBUFF[3][16];
uint8_t Compare[48];
uint8_t DIIPhase[2]={0,0};
uint8_t OldDIIPhase[2]={0,0};

float DIITrack[2];
/*
===============================================================================
                                 Chip Diagram
===============================================================================

                               ______________
                              |AddressDecoder|
                       A4 x---|1           24|---x Vcc                      
                       A5 x---|2           23|---x ROM2                     
                       A6 x---|3           22|---x ROM1                     
                       A7 x---|4           21|---x ROM0                     
                       A8 x---|5           20|---x IO2                      
                       A9 x---|6           19|---x IO1                      
                      A10 x---|7           18|---x IO0                      
                      A11 x---|8           17|---x ENABLE                   
                      A12 x---|9           16|---x SEL2                     
                      A13 x---|10          15|---x SEL1                     
                      A14 x---|11          14|---x SEL0                     
                      GND x---|12          13|---x A15                      
                              |______________|

 */
static const uint8_t DELAYBLOCK[48] PROGMEM =  
{
    162, 255, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 
    234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 
    234, 234, 234, 234, 234, 234, 234, 234, 202, 224,   0, 208, 213,  76,   0, 200
  }; // 6502 Program that just makes a loop till interrupt, or 5 million cycles ( 5 seconds)

static const uint8_t DISKIIROM[] PROGMEM ={
  0xA2, 0x20, 0xA0, 0x00, 0xA2, 0x03, 0x86, 0x3C,
  0x8A, 0x0A, 0x24, 0x3C, 0xF0, 0x10, 0x05, 0x3C,
  0x49, 0xFF, 0x29, 0x7E, 0xB0, 0x08, 0x4A, 0xD0,
  0xFB, 0x98, 0x9D, 0x56, 0x03, 0xC8, 0xE8, 0x10,
  0xE5, 0x20, 0x58, 0xFF, 0xBA, 0xBD, 0x00, 0x01,
  0x0A, 0x0A, 0x0A, 0x0A, 0x85, 0x2B, 0xAA, 0xBD,
  0x8E, 0xC0, 0xBD, 0x8C, 0xC0, 0xBD, 0x8A, 0xC0,
  0xBD, 0x89, 0xC0, 0xA0, 0x50, 0xBD, 0x80, 0xC0,
  0x98, 0x29, 0x03, 0x0A, 0x05, 0x2B, 0xAA, 0xBD,
  0x81, 0xC0, 0xA9, 0x56, 0x20, 0xA8, 0xFC, 0x88,
  0x10, 0xEB, 0x85, 0x26, 0x85, 0x3D, 0x85, 0x41,
  0xA9, 0x08, 0x85, 0x27, 0x18, 0x08, 0xBD, 0x8C,
  0xC0, 0x10, 0xFB, 0x49, 0xD5, 0xD0, 0xF7, 0xBD,
  0x8C, 0xC0, 0x10, 0xFB, 0xC9, 0xAA, 0xD0, 0xF3,
  0xEA, 0xBD, 0x8C, 0xC0, 0x10, 0xFB, 0xC9, 0x96,
  0xF0, 0x09, 0x28, 0x90, 0xDF, 0x49, 0xAD, 0xF0,
  0x25, 0xD0, 0xD9, 0xA0, 0x03, 0x85, 0x40, 0xBD,
  0x8C, 0xC0, 0x10, 0xFB, 0x2A, 0x85, 0x3C, 0xBD,
  0x8C, 0xC0, 0x10, 0xFB, 0x25, 0x3C, 0x88, 0xD0,
  0xEC, 0x28, 0xC5, 0x3D, 0xD0, 0xBE, 0xA5, 0x40,
  0xC5, 0x41, 0xD0, 0xB8, 0xB0, 0xB7, 0xA0, 0x56,
  0x84, 0x3C, 0xBC, 0x8C, 0xC0, 0x10, 0xFB, 0x59,
  0xD6, 0x02, 0xA4, 0x3C, 0x88, 0x99, 0x00, 0x03,
  0xD0, 0xEE, 0x84, 0x3C, 0xBC, 0x8C, 0xC0, 0x10,
  0xFB, 0x59, 0xD6, 0x02, 0xA4, 0x3C, 0x91, 0x26,
  0xC8, 0xD0, 0xEF, 0xBC, 0x8C, 0xC0, 0x10, 0xFB,
  0x59, 0xD6, 0x02, 0xD0, 0x87, 0xA0, 0x00, 0xA2,
  0x56, 0xCA, 0x30, 0xFB, 0xB1, 0x26, 0x5E, 0x00,
  0x03, 0x2A, 0x5E, 0x00, 0x03, 0x2A, 0x91, 0x26,
  0xC8, 0xD0, 0xEE, 0xE6, 0x27, 0xE6, 0x3D, 0xA5,
  0x3D, 0xCD, 0x00, 0x08, 0xA6, 0x2B, 0x90, 0xDB,
  0x4C, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00
};
static const uint8_t HDROM[256] PROGMEM =
{
   0xA9,0x20,0xA9,0x00,0xA9,0x03,0xA9,0x3C,0xD0,0x08,0x38,0xB0,0x01,0x18,0xB0,0x60,
   0x90,0x11,0xA9,0x00,0x8D,0xF2,0xC0,0xA9,0x70,0x8D,0xF3,0xC0,0x48,0x4C,0x4D,0xC7,
   0x4C,0x00,0xC6,0x68,0x85,0x46,0x68,0x85,0x47,0x48,0xA5,0x46,0x69,0x03,0x48,0xA0,
   0x01,0xB1,0x46,0x85,0x42,0xC8,0xD0,0x00,0xB1,0x46,0x85,0x45,0xC8,0xB1,0x46,0x85,
   0x46,0xA0,0x01,0xB1,0x45,0x85,0x43,0xC8,0xB1,0x45,0x85,0x44,0xC8,0xA9,0x70,0x85,
   0x43,0xA9,0x00,0x85,0x44,0x85,0x46,0x85,0x47,0xA9,0x08,0x85,0x45,0xA9,0x01,0x85,
   0x42,0x20,0x70,0xC7,0xB0,0xBA,0x2C,0x61,0xC0,0x30,0xB5,0xA2,0x70,0x4C,0x01,0x08,
   0x18,0xA5,0x42,0x8D,0xF2,0xC0,0xA5,0x43,0x8D,0xF3,0xC0,0xA5,0x44,0x8D,0xF4,0xC0,
   0xA5,0x45,0x8D,0xF5,0xC0,0xA5,0x46,0x8D,0xF6,0xC0,0xA5,0x47,0x8D,0xF7,0xC0,0xAD,
   0xF0,0xC0,0x48,0xA5,0x42,0xC9,0x01,0xD0,0x03,0x20,0xAE,0xC7,0xC9,0x02,0xD0,0x03,
   0x20,0xC3,0xC7,0xAD,0xF1,0xC0,0x18,0xC9,0x01,0xD0,0x01,0x38,0x68,0x60,0x98,0x48,
   0xA0,0x00,0x20,0xF2,0xC7,0xAE,0xFA,0xC0,0x20,0xD8,0xC7,0xCA,0xD0,0xFA,0xC6,0x45,
   0x68,0xA8,0x60,0x98,0x48,0xA0,0x00,0x20,0xF2,0xC7,0xAE,0xFA,0xC0,0x20,0xE5,0xC7,
   0xCA,0xD0,0xFA,0xC6,0x45,0x68,0xA8,0x60,0xAD,0xF8,0xC0,0x91,0x44,0xC8,0xD0,0xF8,
   0xE6,0x45,0xA0,0x00,0x60,0xB1,0x44,0x8D,0xF8,0xC0,0xC8,0xD0,0xF8,0xE6,0x45,0xA0,
   0x00,0x60,0xAD,0xF1,0xC0,0xD0,0xFB,0x60,0x00,0x00,0x00,0x00,0xFF,0x7F,0xBF,0x0A,

  };
  int PhaseTest(uint8_t DII)
  {
    switch (OldDIIPhase[DII])
    {
    case 0:
    if (DIIPhase[DII]==3)DIITrack[DII]-=.25;
    if (DIIPhase[DII]==1)DIITrack[DII]+=.25;
    break;
    case 1:
    if (DIIPhase[DII]==2)DIITrack[DII]+=.25;
    if (DIIPhase[DII]==0)DIITrack[DII]-=.25;
    break;
    case 2:
    if (DIIPhase[DII]==3)DIITrack[DII]+=.25;
    if (DIIPhase[DII]==1)DIITrack[DII]-=.25;
    break;
    case 3:
    if (DIIPhase[DII]==0)DIITrack[DII]+=.25;
    if (DIIPhase[DII]==2)DIITrack[DII]-=.25;
    break;
    }  
    OldDIIPhase[DII]=DIIPhase[DII];
  }
void CardInterrupt1(void) // Selectable Peripheral Phasor II or Ethernet or Accelerator
{
  uint8_t *oldbuffer = Compare; 
GetIO(1);
memcpy(oldbuffer, IOBUFF, 16);
}
void CardInterrupt2(void) // Disk II controller
{
  uint8_t *oldbuffer = Compare+16; 
GetIO(2);
memcpy(oldbuffer, IOBUFF, 16);
}
void CardInterrupt3(void) // Hard Disk Controller
{
  uint8_t *oldbuffer = Compare+32; 
GetIO(3);
memcpy(oldbuffer, IOBUFF, 16);
}

 void enableWrite( void ){
  RWEnable=LOW;
  DATADirection = WRITE;
  //RWEnable = WRITE;
    //PIND=1;
}
 void enableRead( void ){
  RWEnable=HIGH;
  DATADirection = READ;
  //PIND = 1;
}
typedef union {
  uint8_t nibble[2];
  unsigned short whole;
  } Address;
Address address;
static uint8_t data;
void writeTP(void){
  RWEnable=HIGH;
  //address1.whole = address;
  HIGHADDR=address.nibble[1];
  LOWADDR=address.nibble[0];
  enableWrite();
  DATAIO=data;
  enableRead();
  
}
void readTP(void){
  HIGHADDR=address.nibble[1];
  LOWADDR=address.nibble[0];
  enableRead();
  data = DATAIO & 0xFF;
  }
void memsetTP(uint16_t destaddress, uint8_t *buffer, uint16_t len)
{
  address.whole = destaddress;
  uint16_t maxaddr = address.whole+len;
  uint16_t current = 0;
  for(; address.whole < maxaddr; address.whole++ )
  {
    data=buffer[current];
    writeTP();
    current++;  
  }
}
void GetIO(unsigned short card) // READ IO ADDRESSES AD CARD card
{ 
  uint16_t destaddress = (card*16)%48;
  uint8_t counter = 0;
  uint16_t maxaddr = (destaddress+16)&0xFF;
  address.whole=destaddress;
  for(address.nibble[0]=destaddress&0xFF; address.nibble[0] < maxaddr; address.nibble[0]++)
  {
    //readTP();
    enableRead();
    IOBUFF[card][counter]=DATAIO;
    counter++;
  }
}

void setup() {
  DDRA = WRITE;
  DDRC = WRITE;
  DDRL = WRITE;
  CARD1PIN.input();
  CARD2PIN.input();
  CARD2PIN.input();
  //attachInterrupt(digitalPinToInterrupt(pin), isrfunc, mode);
attachInterrupt(digitalPinToInterrupt(21), CardInterrupt1, RISING);
// GAL Trigger IO0 == HIGH + RW == low
attachInterrupt(digitalPinToInterrupt(20), CardInterrupt2, RISING);
// GAL Trigger IO1 == HIGH + RW == low
attachInterrupt(digitalPinToInterrupt(19), CardInterrupt3, RISING);
// GAL Trigger IO2 == HIGH + RW == low

//  CLI();
  // put your setup code here, to run once:
//  SEI();
Serial.begin(2000000);
//  CLI();
}//end setup()

void loop() {
#ifdef TESTING    
  while(1){
    Serial2.println("LOL ");

for(address.whole=0;address.whole <= 2048;address.whole++){
  for(data=0;data<=255;data++){
      writeTP();
    }
  }

}

Serial.println("2");
#endif //ifdef TESTING
  // put your main code here, to run repeatedly:

}
